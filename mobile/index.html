<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Cell Project Mobile</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/p5.min.js"></script>
</head>
<body>
<h1 style="text-align:center; font-family:Courier; font-weight:bold;">Tap once and move your phone</h1>

<script>
let sensorData = { x: 0, y: 0 };
const CONFIG = {
  cellCount: 15,
  otherScaleMin: 15,
  otherScaleMax: 35,
  otherRingCountMin: 10,
  otherRingCountMax: 47,
  otherStrokeAlphaMin: 15,
  otherStrokeAlphaMax: 60,
  playerAlpha: 300,
  rocketSpawnRate: 0.05,
  rocketSpeed: 8,
  noiseDensity: 20000,
  noiseAlpha: 100,
  gridSize: 50,
  gridColor: 200,
  gridAlpha: 180,
  showGridLabels: true,
  gridTextColor: 120,
  showDataText: true
};

let cells = [];
let rockets = [];
let playerCell;

// ==========================================
// 请求陀螺仪权限
document.body.addEventListener("click", async () => {
  if (typeof DeviceMotionEvent !== "undefined" && typeof DeviceMotionEvent.requestPermission === "function") {
    try {
      const res = await DeviceMotionEvent.requestPermission();
      if (res === "granted") startMotion();
      else alert("陀螺仪权限未授权");
    } catch (err) {
      alert("请求陀螺仪权限失败");
      console.error(err);
    }
  } else {
    startMotion();
  }
}, { once: true });

function startMotion() {
  console.log("Motion started");
  window.addEventListener("devicemotion", (e) => {
    sensorData.x = e.accelerationIncludingGravity?.x || 0;
    sensorData.y = e.accelerationIncludingGravity?.y || 0;
  });
}

// ==========================================
// p5.js 核心逻辑
function setup() {
  createCanvas(windowWidth, windowHeight);
  for (let i = 0; i < CONFIG.cellCount; i++) {
    cells.push(new BioCell(random(width), random(height), false));
  }
  playerCell = new BioCell(width/2, height/2, true);
  textFont('Courier New');
  textStyle(BOLD);
}

function draw() {
  background(240);
  drawGridSystem();
  drawNoisyBackground();

  playerCell.applySensorForce(sensorData.x, sensorData.y);
  playerCell.update();
  playerCell.display();
  playerCell.checkEdges();

  for (let c of cells) {
    c.autonomousMove();
    c.update();
    c.display();
    c.checkEdges();
    if (playerCell.intersects(c)) playerCell.resolveCollision(c);
    for (let other of cells) {
      if (c !== other && c.intersects(other)) c.resolveCollision(other);
    }
  }

  manageRockets();
  drawUI();
}

function manageRockets() {
  if (random(1) < CONFIG.rocketSpawnRate) rockets.push(new Rocket());
  for (let i = rockets.length-1; i>=0; i--) {
    let r = rockets[i];
    r.update();
    r.display();
    if (playerCell.intersects(r)) {
      let pushBack = p5.Vector.sub(playerCell.pos, r.pos).normalize().mult(20);
      playerCell.vel.add(pushBack);
      playerCell.pos.add(pushBack);
      // 电子碰撞音效
      if (typeof AudioContext !== "undefined") {
        let ctx = new (window.AudioContext || window.webkitAudioContext)();
        let o = ctx.createOscillator();
        o.type = "square"; o.frequency.value = 300 + random(200);
        o.connect(ctx.destination);
        o.start(); o.stop(ctx.currentTime + 0.05);
      }
      background(255,200,200,100);
    }
    if (r.isOffScreen()) rockets.splice(i,1);
  }
}

function drawGridSystem() {
  push();
  textSize(8); textAlign(LEFT,TOP);
  for(let x=0;x<width;x+=CONFIG.gridSize){
    stroke(CONFIG.gridColor, CONFIG.gridAlpha); strokeWeight(1); line(x,0,x,height);
    if(CONFIG.showGridLabels){ noStroke(); fill(CONFIG.gridTextColor); text(x,x+2,2);}
  }
  for(let y=0;y<height;y+=CONFIG.gridSize){
    stroke(CONFIG.gridColor, CONFIG.gridAlpha); strokeWeight(1); line(0,y,width,y);
    if(CONFIG.showGridLabels){ noStroke(); fill(CONFIG.gridTextColor); text(y,2,y+2);}
  }
  pop();
}

function drawNoisyBackground(){
  push();
  stroke(0,CONFIG.noiseAlpha); strokeWeight(1);
  for(let i=0;i<CONFIG.noiseDensity;i++){ point(random(width),random(height));}
  pop();
}

function drawUI(){
  fill(0); noStroke(); textSize(12); textAlign(LEFT);
  text("SYSTEM: ONLINE",20,30);
  fill(80); text(`THREATS: ${rockets.length}`,20,50);
  fill(100); text("INPUT X: "+sensorData.x.toFixed(2),20,90);
  text("INPUT Y: "+sensorData.y.toFixed(2),20,105);
}

// ==========================================
// Rocket 类
class Rocket{
  constructor(){
    this.r = 30;
    let axis=random()<0.5?'H':'V'; let dir=random()<0.5?1:-1;
    if(axis==='H'){ this.pos=createVector(dir===1?-50:width+50, random(height)); this.vel=createVector(dir*CONFIG.rocketSpeed,0);}
    else{ this.pos=createVector(random(width), dir===1?-50:height+50); this.vel=createVector(0,dir*CONFIG.rocketSpeed);}
  }
  update(){ this.pos.add(this.vel);}
  display(){
    push(); translate(this.pos.x,this.pos.y); rotate(this.vel.heading()); noStroke();
    fill(0,random(180,255)); rect(15,0,20,20);
    for(let i=0;i<5;i++){ fill(0,random(50,150)); let size=random(10,25); rect(random(-20,10),random(-5,5),size,size);}
    for(let i=0;i<8;i++){ fill(0,random(10,50)); let size=random(5,15); rect(random(-40,-10),random(-8,8),size,size);}
    if(frameCount%10<5){ fill(255,0,0); textSize(8); textAlign(CENTER); text("WARNING",0,-25);}
    pop();
  }
  isOffScreen(){ return (this.pos.x<-100 || this.pos.x>width+100 || this.pos.y<-100 || this.pos.y>height+100);}
}

// ==========================================
// BioCell 类
class BioCell{
  constructor(x,y,isPlayer){
    this.pos=createVector(x,y); this.vel=createVector(0,0); this.acc=createVector(0,0);
    this.isPlayer=isPlayer; this.noiseOffset=random(1000); this.maxSpeed=random(3,7); this.changeRate=random(0.01,0.03);
    if(this.isPlayer){ this.r=60;} 
    else{ this.r=random(CONFIG.otherScaleMin,CONFIG.otherScaleMax); this.ringCount=floor(random(CONFIG.otherRingCountMin,CONFIG.otherRingCountMax+1));}
  }
  applySensorForce(gx,gy){ if(this.isPlayer){ let force=createVector(gx*0.2,gy*0.2); this.acc.add(force);}}
  autonomousMove(){ if(!this.isPlayer){ let angle=noise(this.noiseOffset)*TWO_PI*4; let steer=p5.Vector.fromAngle(angle); let excitement=noise(this.noiseOffset+5000); let forceMag=excitement>0.6?1.5:0.3; steer.setMag(forceMag); this.acc.add(steer); this.noiseOffset+=this.changeRate;}}
  update(){ this.vel.add(this.acc); this.vel.limit(this.isPlayer?10:this.maxSpeed); this.pos.add(this.vel); this.vel.mult(0.96); this.acc.mult(0);}
  display(){
    push(); translate(this.pos.x,this.pos.y);
    if(this.isPlayer){
      rotate(frameCount*0.01); noFill();
      let a=CONFIG.playerAlpha; let coilColors=[color(50,200,100,a), color(220,200,50,a), color(220,80,80,a), color(50,150,240,a), color(255,140,20,a), color(20,220,220,a)];
      for(let i=0;i<8;i++){ let col=coilColors[i%coilColors.length]; fill(col); noStroke();
        let baseRadius=map(i,0,7,this.r*0.3,this.r); let numDots=80+i*10;
        for(let j=0;j<numDots;j++){ let angle=map(j,0,numDots,0,TWO_PI); let r=baseRadius+random(-3,3); let theta=angle+random(-0.05,0.05); let xOff=r*cos(theta); let yOff=r*sin(theta); let dotSize=random(1.5,4); ellipse(xOff,yOff,dotSize,dotSize);}}}
    else{
      noFill(); strokeWeight(1.2);
      for(let i=0;i<this.ringCount;i++){
        push(); let angle=map(i,0,this.ringCount,0,TWO_PI); rotate(angle+random(-0.1,0.1));
        stroke(0,random(CONFIG.otherStrokeAlphaMin,CONFIG.otherStrokeAlphaMax));
        let majorAxis=this.r*2; let minorAxis=majorAxis*random(0.3,0.95);
        ellipse(0,0,majorAxis,minorAxis); pop();
      }}
    if(frameCount%20===0&&CONFIG.showDataText){ fill(0,255,0); noStroke(); textSize(10); textAlign(CENTER); text(`[${floor(this.pos.x)},${floor(this.pos.y)}]`,0,-this.r-15);}
    pop();
  }
  checkEdges(){ if(this.pos.x<this.r){this.pos.x=this.r;this.vel.x*=-1;this.acc.add(createVector(2,0));} 
                 if(this.pos.x>width-this.r){this.pos.x=width-this.r;this.vel.x*=-1;this.acc.add(createVector(-2,0));} 
                 if(this.pos.y<this.r){this.pos.y=this.r;this.vel.y*=-1;this.acc.add(createVector(0,2));} 
                 if(this.pos.y>height-this.r){this.pos.y=height-this.r;this.vel.y*=-1;this.acc.add(createVector(0,-2));}}
  intersects(other){ return dist(this.pos.x,this.pos.y,other.pos.x,other.pos.y)<this.r+other.r;}
  resolveCollision(other){ let vCollision=p5.Vector.sub(other.pos,this.pos); let distance=vCollision.mag(); let vCollisionNorm=vCollision.copy().normalize(); let overlap=(this.r+other.r)-distance; if(overlap>0){ let adjustment=vCollisionNorm.copy().mult(overlap/2); this.pos.sub(adjustment); other.pos.add(adjustment);} let speed=this.vel.mag(); other.vel.add(vCollisionNorm.mult(speed*0.8)); this.vel.mult(0.5);}
}

function windowResized(){ resizeCanvas(windowWidth,windowHeight);}
</script>
</body>
</html>
